{"ast":null,"code":"////////////////////////////////////////////////////////////////////////////////\n// A minimal Trie, supporting just the API we need for this Boggle solver.\nfunction TrieNode(character) {\n  this.character = character;\n  this.parent = null;\n  this.children = {};\n  this.isWord = false;\n} // Returns the word corresponding to this node.\n\n\n_c = TrieNode;\n\nTrieNode.prototype.asFullWord = function () {\n  var output = [];\n  var node = this;\n\n  while (node !== null) {\n    output.push(node.character);\n    node = node.parent;\n  }\n\n  output.reverse();\n  return output.join('');\n};\n\nfunction trieInsert(root, word) {\n  let node = root;\n\n  for (let i = 0; i < word.length; ++i) {\n    let c = word[i]; // If 'Q' is the final letter, word[i+1] is undefined\n\n    if (c === 'Q' && word[i + 1] === 'U') {\n      c = 'QU';\n      i = i + 1;\n    }\n\n    if (node.children[c] === undefined) {\n      node.children[c] = new TrieNode(c);\n      node.children[c].parent = node;\n    }\n\n    node = node.children[c];\n  }\n\n  node.isWord = true;\n} ////////////////////////////////////////////////////////////////////////////////\n// The solver itself. We use a helper struct, to simplify argument passing.\n\n\nfunction Solver(dict, grid) {\n  this.trieRoot = new TrieNode();\n\n  for (let word of dict) {\n    trieInsert(this.trieRoot, word);\n  }\n\n  this.grid = grid;\n  this.solutions = new Set();\n}\n\n_c2 = Solver;\n\nSolver.prototype.solve = function () {\n  for (let row = 0; row < this.grid.length; ++row) {\n    for (let col = 0; col < this.grid[0].length; ++col) {\n      this.recursiveSolve(row, col, this.trieRoot);\n    }\n  }\n};\n\nSolver.prototype.recursiveSolve = function (row, col, parentNode) {\n  if (row < 0 || row >= this.grid.length || col < 0 || col >= this.grid[0].length) return;\n  const currentTile = this.grid[row][col];\n  const currentNode = parentNode.children[currentTile];\n  if (currentNode === undefined) return; // '==' matches null or undef\n\n  console.log(\"currentNode\");\n  console.log(currentNode);\n\n  if (currentNode.isWord) {\n    if (currentNode.asFullWord().length >= 3) {\n      this.solutions.add(currentNode.asFullWord());\n    }\n  }\n\n  this.grid[row][col] = '.'; // Mark the cell, so we don't repeat it.\n\n  for (let dx = -1; dx < 2; ++dx) {\n    for (let dy = -1; dy < 2; ++dy) {\n      this.recursiveSolve(row + dx, col + dy, currentNode);\n    }\n  }\n\n  this.grid[row][col] = currentTile; // Unmark the cell.\n}; ////////////////////////////////////////////////////////////////////////////////\n// The public API\n\n\nfunction findAllSolutions(grid, dict) {\n  console.log(\"findAllSolutions\");\n  let solver = new Solver(dict, grid);\n  solver.solve();\n  return [...solver.solutions];\n}\n\nexport default findAllSolutions;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"TrieNode\");\n$RefreshReg$(_c2, \"Solver\");","map":{"version":3,"sources":["C:/Users/sandesh/Desktop/bogglehw/src/solver.js"],"names":["TrieNode","character","parent","children","isWord","prototype","asFullWord","output","node","push","reverse","join","trieInsert","root","word","i","length","c","undefined","Solver","dict","grid","trieRoot","solutions","Set","solve","row","col","recursiveSolve","parentNode","currentTile","currentNode","console","log","add","dx","dy","findAllSolutions","solver"],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////////\r\n// A minimal Trie, supporting just the API we need for this Boggle solver.\r\n\r\nfunction TrieNode(character) {\r\n    this.character = character;\r\n    this.parent = null;\r\n    this.children = {};\r\n    this.isWord = false;\r\n  }\r\n  \r\n  // Returns the word corresponding to this node.\r\n  TrieNode.prototype.asFullWord = function() {\r\n    var output = [];\r\n    var node = this;\r\n  \r\n    while (node !== null) {\r\n      output.push(node.character);\r\n      node = node.parent;\r\n    }\r\n  \r\n    output.reverse();\r\n    return output.join('');\r\n  };\r\n  \r\n  function trieInsert(root, word) {\r\n      let node = root;\r\n      for (let i = 0; i < word.length; ++i) {\r\n      let c = word[i];\r\n      // If 'Q' is the final letter, word[i+1] is undefined\r\n      if (c === 'Q' && word[i + 1] === 'U') {\r\n          c = 'QU';\r\n          i = i + 1;\r\n      }\r\n      if (node.children[c] === undefined) {\r\n          node.children[c] = new TrieNode(c);\r\n          node.children[c].parent = node;\r\n      }\r\n       node = node.children[c];\r\n    }\r\n    node.isWord = true;\r\n  }\r\n  \r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // The solver itself. We use a helper struct, to simplify argument passing.\r\n  \r\n  function Solver(dict, grid) {\r\n      this.trieRoot = new TrieNode();\r\n      for (let word of dict) {\r\n      trieInsert(this.trieRoot, word);\r\n      }\r\n      this.grid = grid;\r\n      this.solutions = new Set();\r\n  }\r\n  \r\n  Solver.prototype.solve = function() {\r\n    for (let row = 0; row < this.grid.length; ++row) {\r\n      for (let col = 0; col < this.grid[0].length; ++col) {\r\n        this.recursiveSolve(row, col, this.trieRoot);\r\n      }\r\n    }\r\n  };\r\n  \r\n  Solver.prototype.recursiveSolve = function(row, col, parentNode) {\r\n    if (row < 0 || row >= this.grid.length || col < 0 || col >= this.grid[0].length) return;\r\n  \r\n    const currentTile = this.grid[row][col];\r\n    const currentNode = parentNode.children[currentTile];\r\n    if (currentNode === undefined) return;  // '==' matches null or undef\r\n    console.log(\"currentNode\");\r\n    console.log(currentNode);\r\n  \r\n    if (currentNode.isWord) {\r\n        if(currentNode.asFullWord().length >= 3) { \r\n            this.solutions.add(currentNode.asFullWord());\r\n        }\r\n    }\r\n    this.grid[row][col] = '.';  // Mark the cell, so we don't repeat it.\r\n  \r\n    for (let dx = -1; dx < 2; ++dx) {\r\n      for (let dy = -1; dy < 2; ++dy) {\r\n        this.recursiveSolve(row + dx, col + dy, currentNode);\r\n      }\r\n    }\r\n  \r\n    this.grid[row][col] = currentTile;  // Unmark the cell.\r\n  };\r\n  \r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // The public API\r\n  \r\n  function findAllSolutions(grid, dict) {\r\n    console.log(\"findAllSolutions\");\r\n    let solver = new Solver(dict, grid);\r\n    solver.solve();\r\n    return [...solver.solutions];\r\n  }\r\n  \r\n  export default findAllSolutions;\r\n  "]},"metadata":{},"sourceType":"module"}